// Copyright (c) 2013 Jae-jun Kang
// See the file COPYING for license details.

using System;
using System.Collections.Generic;
using System.IO;

namespace xpiler {
  class CSharpFormatter : IFormatter {
    class Context {
      public StreamWriter @out;
      public Document doc;
      public Definition def;
      public string target;
      public bool isEvent;
    }

    private const string Extension = ".cs";

    private static readonly Dictionary<string, string> nativeTypes;

    public string Description {
      get { return "C#"; }
    }

    static CSharpFormatter() {
      nativeTypes = new Dictionary<string, string>();

      nativeTypes.Add("int8", "sbyte");
      nativeTypes.Add("int16", "short");
      nativeTypes.Add("int32", "int");
      nativeTypes.Add("int64", "long");

      nativeTypes.Add("string", "string");
    }

    public bool Format(Document doc) {
      try {
        Context context = new Context();
        context.doc = doc;
        context.target = Path.Combine(doc.DirName, doc.BaseName + Extension);
        using (StreamWriter file = new StreamWriter(context.target)) {
          context.@out = file;
          FormatHeader(context);
          if (doc.Namespaces != null) {
            BeginNamespace(context);
          }
          FormatBody(context);
          if (doc.Namespaces != null) {
            EndNamespace(context);
          }
        }
      } catch (Exception e) {
        Console.Error.WriteLine(e.Message);
        return false;
      }
      return true;
    }

    public bool IsUpToDate(Document doc) {
      string target = Path.Combine(doc.DirName, doc.BaseName + Extension);
      return (File.Exists(target) &&
              File.GetLastWriteTime(target) >= File.GetLastWriteTime(doc.Path));
    }

    private void FormatHeader(Context context) {
      context.@out.WriteLine("// auto-generated by xpiler\n");
      context.@out.WriteLine("using x2;\n");
    }

    private void BeginNamespace(Context context) {
      string joined = String.Join(".", context.doc.Namespaces);
      context.@out.WriteLine("namespace {0} {{", joined);
    }

    private void EndNamespace(Context context) {
      string joined = String.Join(".", context.doc.Namespaces);
      context.@out.WriteLine("}}  // namespace {0}", joined);
    }

    private void FormatBody(Context context) {
      foreach (Definition def in context.doc.Definitions) {
        if (def != context.doc.Definitions[0]) {
          context.@out.WriteLine();
        }
        switch (def.Type) {
          case Definition.EnumType:
            context.def = def;
            FormatEnum(context);
            break;
          case Definition.CellType:
          case Definition.EventType:
            context.def = def;
            context.isEvent = (def.Type == Definition.EventType);
            FormatCell(context);
            break;
          default:
            break;
        }
      }
    }

    private void FormatEnum(Context context) {
      StreamWriter @out = context.@out;
      EnumDef def = (EnumDef)context.def;
      @out.WriteLine("  enum {0} {{", def.Name);
      foreach (EnumDef.Element element in def.Elements) {
        @out.Write("    {0}", element.Name);
        if (!String.IsNullOrEmpty(element.Value)) {
          @out.Write(" = {0}", element.Value);
        }
        if (element != def.Elements[def.Elements.Count - 1]) {
          @out.Write(",");
        }
        @out.WriteLine();
      }
      @out.WriteLine("  }");
    }

    private void FormatCell(Context context) {
      StreamWriter @out = context.@out;
      CellDef def = (CellDef)context.def;
      string inheritee = def.Inheritee;
      if (String.IsNullOrEmpty(inheritee)) {
        inheritee = (context.isEvent ? "Event" : "Cell");
      }
      PreprocessProperties(context);

      @out.WriteLine("  class {0} : {1} {{", def.Name, inheritee);
      @out.WriteLine("    new protected static readonly Tag tag;\n");
      FormatFields(context);
      if (def.Properties.Count != 0) {
        @out.WriteLine();
      }
      FormatProperties(context);
      if (def.Properties.Count != 0) {
        @out.WriteLine();
      }
      FormatMethods(context);
      @out.WriteLine("  }");
    }

    private void FormatFields(Context context) {
      CellDef def = (CellDef)context.def;
      foreach (CellDef.Property property in def.Properties) {
        context.@out.WriteLine("    private {0} {1};",
                               property.NativeType, property.NativeName);
      }
    }

    private void FormatProperties(Context context) {
      StreamWriter @out = context.@out;
      CellDef def = (CellDef)context.def;
      foreach (CellDef.Property property in def.Properties) {
        if (property != def.Properties[0]) {
          @out.WriteLine();
        }
        @out.WriteLine("    public {0} {1} {{",
                       property.NativeType, property.Name);
        @out.WriteLine("      get {{ return {0}; }}", property.NativeName);
        @out.WriteLine("      set {");
        @out.WriteLine("        fingerprint.Touch(tag.Offset + {0});",
                       property.Index);
        @out.WriteLine("        {0} = value;", property.NativeName);
        @out.WriteLine("      }");
        @out.WriteLine("    }");
      }
    }

    private void FormatMethods(Context context) {
      FormatStaticConstructor(context);
      context.@out.WriteLine("    // methods...");
    }

    private void FormatStaticConstructor(Context context) {
      StreamWriter @out = context.@out;
      CellDef def = (CellDef)context.def;
      @out.WriteLine("    static {0}() {{", def.Name);
      /*
      @out.WriteLine("      tag = new Tag({0}.tag, typeof({1}), {2}, {3});",
                     def.Inheritee, def.Name, );
      */
      @out.WriteLine("    }");
    }

    private void PreprocessProperties(Context context) {
      CellDef def = (CellDef)context.def;
      int index = 0;
      foreach (CellDef.Property property in def.Properties) {
        property.NativeName = FirstToLower(property.Name);
        property.NativeType = nativeTypes[property.Type];
        property.Name = FirstToUpper(property.Name);
        property.Index = index++;
      }
    }

    private static string FirstToLower(string s) {
      if (!String.IsNullOrEmpty(s)) {
        char[] chars = s.ToCharArray();
        if (Char.IsUpper(chars[0])) {
          chars[0] = Char.ToLower(chars[0]);
          return new string(chars);
        }
      }
      return s;
    }

    private static string FirstToUpper(string s) {
      if (!String.IsNullOrEmpty(s)) {
        char[] chars = s.ToCharArray();
        if (Char.IsLower(chars[0])) {
          chars[0] = Char.ToUpper(chars[0]);
          return new string(chars);
        }
      }
      return s;
    }
  }
}
